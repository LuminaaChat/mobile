import { io, Socket } from 'socket.io-client';
import { ChatEntity } from 'src/app/shared/entity/chat/chat.entity';

import { Injectable, signal, WritableSignal } from '@angular/core';

import { Group } from '../../../../chatapi';
import { MessageEntity } from '../../shared/entity/message/message.entity';

export enum CHAT_EVENT {
  CONNECT = 'connect',
  SEND_MSG = 'chat_message',
  ON_RECEIVE_MSG = 'chat_message',
}

@Injectable({ providedIn: 'root' })
export class ChatService {
  chats: WritableSignal<Array<ChatEntity>> = signal([]);
  groups: WritableSignal<Array<Group>> = signal([]);
  private socket: Socket;

  constructor() {
    this.socket = io({ autoConnect: false });
  }

  connectToSocket(username: string) {
    this.socket.auth = { username };
    this.socket.connect();
    this.subscribeToMyChats();
  }

  getMyGroupList() {
    console.warn('Endpoint for groups currently missing');
    const ret = [
      {
        groupChats: [
          { groupChatId: 'test1', groupChatName: 'test1' },
          { groupChatId: 'test2', groupChatName: 'test2' },
        ],
        groupId: '123',
        groupName: 'WG I',
        users: [],
      },
      {
        groupChats: [],
        groupId: '123',
        groupName: 'WG II',
        users: [],
      },
    ] as Group[];
    this.groups.set(ret);
    this.getMyChatList()
  }

  getMyChatList() {
    // hook up chat service, generated by open api
    const ret = [
      {
        id: 'test1',
        participants: ['Dennis', 'Clemens'],
        messages: [
          { message: 'hallo', authorId: 'Dennis', timestamp: new Date() },
          { message: 'wie gehts?', authorId: 'Dennis', timestamp: new Date() },
          { message: 'hallo', authorId: 'Clemens', timestamp: new Date() },
        ],
      },
      {
        id: 'test2',
        participants: ['Dennis', 'Clemens'],
        messages: [
          { message: 'hallo2', authorId: 'Dennis', timestamp: new Date() },
          { message: 'wie gehts?2', authorId: 'Dennis', timestamp: new Date() },
          { message: 'hallo 2', authorId: 'Clemens', timestamp: new Date() },
        ],
      },
    ];
    this.chats.set(ret);
  }

  // socket gedÃ¶hnse
  sendMessageByChatId(msg: MessageEntity) {
    if (this.socket.connected) {
      this.socket.emit(CHAT_EVENT.SEND_MSG, msg);
    } else {
      console.log('no socket found');
      throw 'not implemented yet';
    }
  }

  private subscribeToMyChats() {
    this.socket.on(CHAT_EVENT.CONNECT, () => {
      console.log('connected:', this.socket.id);
    });
    this.socket.on(CHAT_EVENT.ON_RECEIVE_MSG, (msg: MessageEntity) => {
      this.chats.update((chats) => {
        const index = chats.findIndex((c: ChatEntity) => c.id === msg.chatId);
        chats[index].messages.push(msg);
        return JSON.parse(JSON.stringify(chats));
      });
    });
  }
}
